# 基本数据结构
计算机程序 = 数据结构 + 算法， 数据结构是至关重要的一环。

# 数组
**数组**在内存中是： <span style="color: red">**顺序存储**</span>, 元素之间紧密排序。

**内存**: 是由一个个连续的内存单元组成的，每个内存单元都有自己的地址。

## 数组的基本存储形式
内存分配连续的一块，来存储数组，因为数组的每个元素都是连续的，顺序存储。
```
[ 1 ][ 2 ][ 3 ][ 4 ][ 5 ][ 6 ][ 7 ][ 8 ]

  0    1    2    3    4    5    6    7

```

## 数组的基本操作
> 数据结构的基本操作无非就是：增、删、改、查4种情况。

### 数组读取 && 更新
以JavaScript为例
```
var arr = [1,2,3,4,5,6,7]

// 读取
arr[0]


//更新
arr[1] = 2
```
<div style="color: red">数组的读取和更新的时间复杂度都是：<strong> O(1)</strong></div>

### 插入和删除
因为数组的存储空间是连续的，插入和删除在极端的情况下，可能需要连续移动很多元素。

比如插入操作分为：尾部插入、中间插入、超范围插入等。

#### 插入
```
在2的位置插入一个元素： 10

[ 1 ][ 2 ][ 3 ][ 4 ][ 5 ][ 6 ][ 7 ][ 8 ]

      10

第一步: 所有的2以及往后的元素都往后移动一位： 
    [ 1 ][ null ][ 2 ][ 3 ][ 4 ][ 5 ][ 6 ][ 7 ][ 8 ]

第二步：将元素10放到空出来的位置里
    [ 1 ][ 10 ][ 2 ][ 3 ][ 4 ][ 5 ][ 6 ][ 7 ][ 8 ]

```

#### 删除元素
```
删除元素2：
    [ 1 ][ 2 ][ 3 ][ 4 ][ 5 ][ 6 ][ 7 ][ 8 ]

第一步： 将索引为：1的地址清空
    [ 1 ][ null ][ 3 ][ 4 ][ 5 ][ 6 ][ 7 ][ 8 ]

第二步：将后面的所有元素都往前移动一个位置
    [ 1 ][ 3 ][ 4 ][ 5 ][ 6 ][ 7 ][ 8 ]
```

<div style="color: red">数组的删除和插入的时间复杂度都是<strong>O(n)</strong>, 因为基本都涉及到元素的移动</div>

### 数组的优势和劣势(读操作多，写操作少)
**优势**: 查找

**劣势**: 插入和删除

### 注意
数组还需要注意： 数组的扩容情况的，当插入时，如果数组长度不够，就需要考虑扩容。扩容就需要申请内存空间。

------


# 链表
一种物理上非连续、非顺序的数据结构，由若干节点组成。

## 节点结构
这里用JavaScript来表示
```
function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val)
     this.next = (next===undefined ? null : next)
}

var node = new ListNode(1)
```

## 单向链表
单项链表的每一个节点又包含两部分，一部分是存放数据点**data**, 一部分是指向下一个节点的指针**next**
```
[ data | next ] -> [ data | next ] -> [ data | next ] -> null

  header(头节点)                           尾结点
```

## 双向链表
比单项链表复杂，不仅包含了该节点的数据，下一个节点的信息，同时还包含了上一个节点的信息。

双向链表的每个节点，都能**回溯**到它的前置节点。
```
 null <- [ prev | data | next ] ->  <- [ prev | data | next ] -> <- [ prev | data | next ] -> null

```

## 存储
如果说数组是顺序存储， 那么链表就是随机存储。<span style="color: red; font-weight: bold">因为链表有记录上一个节点和下一个节点的功能，可以回溯，所以在存储方面上，不一定要有序。</span>

## 链表的基本操作(增、删、改、查)

### 链表查找元素的时间复杂度是：**O(n)**

```
//找第三个节点

[ data | next ] -> [ data | next ] -> [ data | next ] -> null

```
* 定位到头结点
* 根据头节点的next, 找到下一个节点
* 在根据下一个节点的next, 找到下一个节点

### 删除、插入
忽略查找节点的过程，单单是删除、插入的操作，其时间复杂度为： **O(1)**

删除第三个节点： 
```

[ data | next ] -> [ data | next ] -> [ data | next ] -> null

 先找到第三个节点：


 将第第三个节点的上一个节点的： next指向第三个节点的next就可以了。

```

插入
```
[ data | next ] -> [ data | next ] -> [ data | next ] -> null

在第三个插入一个几点：

创建一个新节点

找到第三个节点位置，将新节点的next -> 第二个节点的next(这里是第三个节点)

第二个节点的next -> 新节点

```

## 链表  VS  数组
<table>
    <tr>
        <td>
        </td>
        <td>
            查找
        </td>
        <td>
            更新
        </td>
        <td>
            插入
        </td>
        <td>
            删除
        </td>
    </tr>
    <tr>
        <td>
            数组
        </td>
        <td>
            O(1)
        </td>
        <td>
            O(1)
        </td>
        <td>
            O(n)
        </td>
        <td>
            O(n)
        </td>
    </tr>
    <tr>
        <td>
            链表
        </td>
        <td>
            O(n)
        </td>
        <td>
            O(1)
        </td>
        <td>
            O(1)
        </td>
        <td>
            O(1)
        </td>
   </tr>
</table>
<br>
数组：能快速定位元素的位置，也就是适用于查找场景

链表：能过灵活的进行**插入**和**删除**

















