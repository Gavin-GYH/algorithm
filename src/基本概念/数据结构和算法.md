<h1 style="text-align: center">数据结构和算法</h1>

## 算法
算法的概念来自于数据领域，是解决问题的一快快捷方式。

### 应用场景
* 运算
* 查找
* 排序
* 最优策略

## 数据结构
算法的基石。如果把算法比作动人的**舞者**，数据结构就是舞者脚下的**舞台**。

### 线性结构
* 数组
* 链表
* 栈
* 队列
* 哈希表
> 栈、队列、哈希表是由数组和链表衍生出来的。

### 树
* 二叉树
    * 满二叉树
    * 完全二叉树
    * 二叉查找树
* 二叉堆
    * 最大堆
    * 最小堆

### 图 & 其他数据结构
* 图
* 跳表
* 哈希链表
* 位图
* 等
> 了解就行。


## 算法的优劣(两个维度)
从两个维度去衡量一个算法的优劣： **时间复杂度** 和 **空间复杂度**，在算法的过程中，更加注重的是时间复杂度。

### 时间复杂度（大O表示法）
时间复杂度就是把程序的相对执行时间函数T(n)简化为一个数量级，这个数量级可以是：n、 n^2、n^3等。

#### 推导时间复杂度
* 如果运行时间是常量级别，则用常数1表示。
* 只保留时间函数中的最高阶项。
* 如果最高阶项存在，则省去最高阶项前面的系数。

### 空间复杂度
描述一个算法占用的内存空间的大小  -->  空间复杂度

#### 常量空间

算法的存储空间大小固定，和输入的规模没有直接关系： **O(1)**

#### 线性空间

当算法分配的空间是一个线性的集合（如列表），并且集合的大小和输入规模n成正比： **O(n)**
```
function arr(n) {
    return new Array(n)
}

arr(100)
arr(1000)
.....
```

#### 二维空间

分配一个二维列表集合，并且集合的长度和宽度都与输入规模n成正比： **O(n^2)**

#### 递归空间

函数递归调用，虽然没有显示的声明变量或者集合，但是计算机会分配一块内存，用来存储**函数的调用栈**。：  **O(n)**


### 时间和空间的取舍
* **时间换空间**
* **空间换时间**

#### 例子

寻找重复整数： 有n个整数，其中两个是重复的，要求找出两个重复的整数。

**时间换空间(双重for)**
```
输入： [2，5，8，12，90，11，12, 33，44，2[]
输出：2

var arr = [2,3,4,5,6,7,8,9,11,12,23,22,13,2]

function findRepeat(arr) {
    for(var i = 0; i < arr.length; i ++) {
        for(var j = 0; j < arr.length; j ++) {
            if(arr[j] === arr[i]) {
                return arr[i]
            }
        }
    }
}

console.log(findRepeat(arr))
```

**空间换时间(字典)**

字典 又称**哈希表**,是一种**散列结构**。需要分配一定的内存在存储数。读写字典的时间复杂度为： **O(1)**
```
function findOfMap(arr) {
    var map = new Map()
    for(var i = 0; i < arr.length; i ++) {
        if(!map.has(arr[i])) {
            map.set(arr[i], 1)
        } else {
            return arr[i]
        }
    } 
}

console.log(findOfMap(arr))
```
